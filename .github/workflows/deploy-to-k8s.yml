name: Deploy to Kubernetes

on:
  workflow_run:
    workflows: ["Backend CI - Build & Push Image"]
    types:
      - completed
    branches: [main]
  workflow_dispatch:

env:
  KUBE_CONFIG: ${{ github.workspace }}/kubeconfig
  NAMESPACE: tasklist
  # Environment variables from GitHub secrets
  DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
  DB_USERNAME: ${{ secrets.DB_USERNAME }}
  DB_URL: ${{ secrets.DB_URL }}
  FRONTEND_API_URL: ${{ secrets.FRONTEND_API_URL }}
  SUDO_PASSWORD: ${{ secrets.SUDO_PASSWORD }}
  ANSIBLE_VAULT_PASSWORD: ${{ secrets.ANSIBLE_VAULT_PASSWORD }}

jobs:
  deploy:
    name: Deploy to Kubernetes
    runs-on: [self-hosted, linux]
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup kubectl
        run: |
          # Ensure kubectl is available
          if ! command -v kubectl &> /dev/null; then
            echo "kubectl not found, installing..."
            curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
            chmod +x kubectl
            sudo mv kubectl /usr/local/bin/
          fi

      - name: Verify MicroK8s cluster
        run: |
          echo "üîç Verifying MicroK8s installation and status..."
          
          # Check if MicroK8s is installed
          if ! command -v microk8s &> /dev/null; then
            echo "‚ùå MicroK8s is not installed. Please install MicroK8s first."
            exit 1
          fi
          echo "‚úÖ MicroK8s is installed: $(microk8s version --client)"
          
          # Check if MicroK8s is running
          if ! microk8s status | grep -q "running"; then
            echo "‚ùå MicroK8s is not running. Starting MicroK8s..."
            microk8s start
            echo "‚è≥ Waiting for MicroK8s to start..."
            microk8s status --wait-ready
          else
            echo "‚úÖ MicroK8s is running"
          fi
          
          # Check required addons
          echo "üîç Checking required MicroK8s addons..."
          REQUIRED_ADDONS="dns storage ingress dashboard metrics-server registry"
          MISSING_ADDONS=""
          
          for addon in $REQUIRED_ADDONS; do
            if microk8s status | grep -q "$addon: enabled"; then
              echo "‚úÖ Addon '$addon' is enabled"
            else
              echo "‚ùå Addon '$addon' is not enabled"
              MISSING_ADDONS="$MISSING_ADDONS $addon"
            fi
          done
          
          if [ -n "$MISSING_ADDONS" ]; then
            echo "‚ùå Missing required addons: $MISSING_ADDONS"
            echo "Please enable them first: microk8s enable$MISSING_ADDONS"
            exit 1
          fi
          
          # Configure kubectl to use MicroK8s
          echo "üîß Configuring kubectl..."
          mkdir -p $HOME/.kube
          microk8s config > $HOME/.kube/config
          chmod 600 $HOME/.kube/config
          
          # Verify cluster access
          echo "üîç Verifying cluster access..."
          if ! kubectl cluster-info >/dev/null 2>&1; then
            echo "‚ùå Cannot access Kubernetes cluster"
            exit 1
          fi
          echo "‚úÖ Kubernetes cluster is accessible"
          
          # Check node status
          if ! kubectl get nodes | grep -q "Ready"; then
            echo "‚ùå Kubernetes nodes are not ready"
            exit 1
          fi
          echo "‚úÖ Kubernetes nodes are ready"
          
          kubectl cluster-info
          kubectl get nodes
          echo "‚úÖ MicroK8s verification completed"

      - name: Install ArgoCD
        run: |
          echo "üîç Verifying ArgoCD installation..."
          
          # Check if ArgoCD namespace exists
          if ! kubectl get namespace argocd >/dev/null 2>&1; then
            echo "üîß Creating ArgoCD namespace..."
            kubectl create namespace argocd
          else
            echo "‚úÖ ArgoCD namespace exists"
          fi
          
          # Check if ArgoCD is already installed
          if kubectl get deployment argocd-server -n argocd >/dev/null 2>&1; then
            echo "‚úÖ ArgoCD is already installed, checking status..."
            kubectl get deployment -n argocd
          else
            echo "üîß Installing ArgoCD..."
            # Install ArgoCD
            kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml
            echo "‚úÖ ArgoCD installed successfully"
          fi
          
          # Wait for ArgoCD to be ready (increased timeout)
          echo "‚è≥ Waiting for ArgoCD to be ready..."
          kubectl wait --for=condition=available --timeout=600s deployment/argocd-server -n argocd
          kubectl wait --for=condition=available --timeout=600s deployment/argocd-repo-server -n argocd
          kubectl wait --for=condition=available --timeout=600s deployment/argocd-application-controller -n argocd
          kubectl wait --for=condition=available --timeout=600s deployment/argocd-dex-server -n argocd
          kubectl wait --for=condition=available --timeout=600s deployment/argocd-redis -n argocd
          kubectl wait --for=condition=available --timeout=600s deployment/argocd-notifications-controller -n argocd
          
          # Verify ArgoCD is healthy
          echo "üîç Verifying ArgoCD health..."
          if ! kubectl get pods -n argocd | grep -q "Running"; then
            echo "‚ùå ArgoCD pods are not running"
            kubectl get pods -n argocd
            exit 1
          fi
          echo "‚úÖ ArgoCD pods are running"
          
          # Check ArgoCD server service
          if ! kubectl get svc argocd-server -n argocd >/dev/null 2>&1; then
            echo "‚ùå ArgoCD server service not found"
            exit 1
          fi
          echo "‚úÖ ArgoCD server service is available"
          
          echo "‚úÖ ArgoCD is ready"

      - name: Create namespace
        run: |
          kubectl create namespace ${{ env.NAMESPACE }} || true

      - name: Create Kubernetes secrets from GitHub secrets
        run: |
          echo "üîê Creating Kubernetes secrets from GitHub secrets..."
          
          # Verify required secrets are available
          echo "üîç Verifying GitHub secrets..."
          REQUIRED_SECRETS="DB_PASSWORD DB_USERNAME DB_URL FRONTEND_API_URL"
          MISSING_SECRETS=""
          
          for secret in $REQUIRED_SECRETS; do
            if [ -z "${!secret}" ]; then
              echo "‚ùå Secret '$secret' is not set"
              MISSING_SECRETS="$MISSING_SECRETS $secret"
            else
              echo "‚úÖ Secret '$secret' is available"
            fi
          done
          
          if [ -n "$MISSING_SECRETS" ]; then
            echo "‚ùå Missing required secrets: $MISSING_SECRETS"
            exit 1
          fi
          
          # Create database secrets
          echo "üîß Creating database secrets..."
          kubectl create secret generic tasklist-db-secrets \
            --from-literal=db-username=$(echo -n "${{ secrets.DB_USERNAME }}" | base64) \
            --from-literal=db-password=$(echo -n "${{ secrets.DB_PASSWORD }}" | base64) \
            --from-literal=db-url=$(echo -n "${{ secrets.DB_URL }}" | base64) \
            -n ${{ env.NAMESPACE }} || true
          
          # Create application secrets
          echo "üîß Creating application secrets..."
          kubectl create secret generic tasklist-app-secrets \
            --from-literal=frontend-api-url="${{ secrets.FRONTEND_API_URL }}" \
            -n ${{ env.NAMESPACE }} || true
          
          # Verify secrets were created
          echo "üîç Verifying secrets were created..."
          if ! kubectl get secret tasklist-db-secrets -n ${{ env.NAMESPACE }} >/dev/null 2>&1; then
            echo "‚ùå Database secrets were not created"
            exit 1
          fi
          
          if ! kubectl get secret tasklist-app-secrets -n ${{ env.NAMESPACE }} >/dev/null 2>&1; then
            echo "‚ùå Application secrets were not created"
            exit 1
          fi
          
          echo "‚úÖ All secrets created successfully"
          kubectl get secrets -n ${{ env.NAMESPACE }}

      - name: Apply Kubernetes manifests
        run: |
          echo "üöÄ Deploying application to Kubernetes..."
          
          # Verify kustomize directory exists
          if [ ! -d "k8s/" ]; then
            echo "‚ùå k8s/ directory not found"
            exit 1
          fi
          
          # Check if kustomization.yaml exists
          if [ ! -f "k8s/kustomization.yaml" ]; then
            echo "‚ùå k8s/kustomization.yaml not found"
            exit 1
          fi
          
          echo "‚úÖ Kubernetes manifests found"
          
          # Validate manifests before applying
          echo "üîç Validating Kubernetes manifests..."
          if ! kubectl kustomize k8s/ > /dev/null; then
            echo "‚ùå Kubernetes manifests validation failed"
            exit 1
          fi
          echo "‚úÖ Kubernetes manifests are valid"
          
          # Apply all manifests using kustomize
          echo "üîß Applying Kubernetes manifests..."
          kubectl apply -k k8s/ -n ${{ env.NAMESPACE }}
          
          # Wait for deployments to be ready (increased timeout)
          echo "‚è≥ Waiting for deployments to be ready..."
          kubectl wait --for=condition=available --timeout=600s deployment -n ${{ env.NAMESPACE }} --all
          
          # Verify deployments are running
          echo "üîç Verifying deployments..."
          if ! kubectl get pods -n ${{ env.NAMESPACE }} | grep -q "Running"; then
            echo "‚ùå Application pods are not running"
            kubectl get pods -n ${{ env.NAMESPACE }}
            exit 1
          fi
          
          # Show deployment status
          echo "üìä Deployment Status:"
          kubectl get pods,svc,ingress -n ${{ env.NAMESPACE }}
          echo "‚úÖ Application deployed successfully"

      - name: Create ArgoCD application
        run: |
          echo "üéØ Creating ArgoCD application..."
          
          # Verify ArgoCD application manifest exists
          if [ ! -f "k8s/argocd/app.yaml" ]; then
            echo "‚ùå ArgoCD application manifest not found"
            exit 1
          fi
          
          # Validate ArgoCD application manifest
          echo "üîç Validating ArgoCD application manifest..."
          if ! kubectl apply --dry-run=client -f k8s/argocd/app.yaml -n argocd >/dev/null; then
            echo "‚ùå ArgoCD application manifest validation failed"
            exit 1
          fi
          echo "‚úÖ ArgoCD application manifest is valid"
          
          # Apply ArgoCD application manifest
          echo "üîß Applying ArgoCD application manifest..."
          kubectl apply -f k8s/argocd/app.yaml -n argocd
          
          # Wait for ArgoCD application to be created
          echo "‚è≥ Waiting for ArgoCD application to be created..."
          if ! kubectl wait --for=condition=Synced --timeout=300s application/tasklist-app -n argocd; then
            echo "‚ö†Ô∏è ArgoCD application sync timeout, but continuing..."
          fi
          
          # Verify ArgoCD application status
          echo "üîç Verifying ArgoCD application..."
          if ! kubectl get application tasklist-app -n argocd >/dev/null 2>&1; then
            echo "‚ùå ArgoCD application was not created"
            exit 1
          fi
          
          # Show ArgoCD application status
          echo "üìä ArgoCD Application Status:"
          kubectl get application tasklist-app -n argocd -o wide
          
          # Check application health
          APP_HEALTH=$(kubectl get application tasklist-app -n argocd -o jsonpath='{.status.health.status}' 2>/dev/null || echo "Unknown")
          echo "Application Health Status: $APP_HEALTH"
          
          echo "‚úÖ ArgoCD application created successfully"

      - name: Verify deployment
        run: |
          echo "üîç Verifying deployment..."
          
          # Check pod health
          kubectl get pods -n ${{ env.NAMESPACE }} -o wide
          
          # Check services
          kubectl get services -n ${{ env.NAMESPACE }}
          
          # Check ingress if available
          kubectl get ingress -n ${{ env.NAMESPACE }} || echo "No ingress resources found"
          
          # Show application URLs
          echo "üåê Application Access:"
          
          # Get NodePort services
          NODE_PORTS=$(kubectl get svc -n ${{ env.NAMESPACE }} --no-headers | grep NodePort | awk '{print $1 ":" $2 ":" $3}')
          if [ -n "$NODE_PORTS" ]; then
            echo "NodePort Services:"
            echo "$NODE_PORTS" | while IFS=':' read -r name type ports; do
              PORT=$(echo $ports | cut -d':' -f1)
              echo "  $name: http://$(hostname -I | awk '{print $1}'):$PORT"
            done
          fi
          
          # Get Ingress hosts
          INGRESS_HOSTS=$(kubectl get ingress -n ${{ env.NAMESPACE }} -o jsonpath='{.items[*].spec.rules[*].host}' 2>/dev/null || echo "")
          if [ -n "$INGRESS_HOSTS" ]; then
            echo "Ingress Hosts:"
            for host in $INGRESS_HOSTS; do
              echo "  http://$host"
            done
          fi

      - name: Troubleshooting info
        if: failure()
        run: |
          echo "üîç Troubleshooting information..."
          
          # Check ArgoCD status
          echo "=== ArgoCD Status ==="
          kubectl get pods -n argocd
          kubectl get deployment -n argocd
          
          # Check application namespace
          echo "=== Application Namespace Status ==="
          kubectl get pods -n ${{ env.NAMESPACE }}
          kubectl get deployment -n ${{ env.NAMESPACE }}
          kubectl get events -n ${{ env.NAMESPACE }} --sort-by='.lastTimestamp' | tail -10
          
          # Check ArgoCD application logs
          echo "=== ArgoCD Application Logs ==="
          kubectl logs -n argocd deployment/argocd-application-controller --tail=20
          
          # Check resource usage
          echo "=== Resource Usage ==="
          kubectl top nodes 2>/dev/null || echo "Metrics server not available"
          kubectl top pods -n argocd 2>/dev/null || echo "Pod metrics not available"

      - name: Run smoke tests
        run: |
          echo "üß™ Running smoke tests..."
          
          # Get application endpoint
          API_ENDPOINT=""
          
          # Try to get NodePort for backend service
          BACKEND_PORT=$(kubectl get svc tasklistapp-service -n ${{ env.NAMESPACE }} -o jsonpath='{.spec.ports[0].nodePort}' 2>/dev/null || echo "")
          if [ -n "$BACKEND_PORT" ]; then
            API_ENDPOINT="http://$(hostname -I | awk '{print $1}'):$BACKEND_PORT"
          fi
          
          # If no NodePort, try Ingress
          if [ -z "$API_ENDPOINT" ]; then
            INGRESS_HOST=$(kubectl get ingress -n ${{ env.NAMESPACE }} -o jsonpath='{.items[0].spec.rules[0].host}' 2>/dev/null || echo "")
            if [ -n "$INGRESS_HOST" ]; then
              API_ENDPOINT="http://$INGRESS_HOST"
            fi
          fi
          
          if [ -n "$API_ENDPOINT" ]; then
            echo "Testing endpoint: $API_ENDPOINT"
            
            # Test health endpoint
            if curl -f -s "$API_ENDPOINT/actuator/health" > /dev/null; then
              echo "‚úÖ Health check passed"
            else
              echo "‚ùå Health check failed"
              exit 1
            fi
            
            # Test API endpoint
            if curl -f -s "$API_ENDPOINT/api/tasks" > /dev/null; then
              echo "‚úÖ API endpoint test passed"
            else
              echo "‚ùå API endpoint test failed"
              exit 1
            fi
          else
            echo "‚ö†Ô∏è Could not determine API endpoint, skipping smoke tests"
          fi

      - name: Save kubeconfig
        if: always()
        run: |
          mkdir -p ${{ github.workspace }}/.kube
          cp ~/.kube/config ${{ env.KUBE_CONFIG }}
        
      - name: Upload kubeconfig
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: kubeconfig
          path: ${{ env.KUBE_CONFIG }}
          if-no-files-found: error
          retention-days: 1
