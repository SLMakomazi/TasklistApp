name: Deploy to Kubernetes

on:
  workflow_run:
    workflows: ["Deploy Infrastructure"]
    types:
      - completed
    branches:
      - main
  workflow_dispatch:

env:
  KUBE_CONFIG: ${{ github.workspace }}/kubeconfig
  NAMESPACE: tasklist
  # Environment variables from GitHub secrets
  DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
  DB_USERNAME: ${{ secrets.DB_USERNAME }}
  DB_URL: ${{ secrets.DB_URL }}
  FRONTEND_API_URL: ${{ secrets.FRONTEND_API_URL }}

jobs:
  deploy:
    name: Deploy to Kujobs
    runs-on: [self-hosted, linux]
    env:
      KUBECONFIG: ${{ github.workspace }}/kubeconfig
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Download kubeconfig
        uses: actions/download-artifact@v4
        with:
          name: kubeconfig
          path: ${{ github.workspace }}

      - name: Verify kubeconfig file
        run: |
          echo "üîç Checking if kubeconfig file exists..."
          ls -la ${{ github.workspace }}/kubeconfig
          if [ -f "${{ github.workspace }}/kubeconfig" ]; then
            echo "‚úÖ Kubeconfig file found"
            echo "üìã Kubeconfig content preview:"
            head -n 5 ${{ github.workspace }}/kubeconfig
          else
            echo "‚ùå Kubeconfig file not found"
            echo "üìÅ Available files:"
            ls -la ${{ github.workspace }}
            exit 1
          fi

      - name: Setup kubectl
        run: |
          if ! command -v kubectl &> /dev/null; then
            echo "kubectl not found, installing..."
            curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
            chmod +x kubectl
            sudo mv kubectl /usr/local/bin/
          fi
          
          # Configure kubectl to use downloaded kubeconfig
          export KUBECONFIG=${{ github.workspace }}/kubeconfig
          
          # Test connection
          echo "üîç Testing kubeconfig connection..."
          kubectl --kubeconfig=${{ github.workspace }}/kubeconfig get nodes
          kubectl --kubeconfig=${{ github.workspace }}/kubeconfig cluster-info
          echo "‚úÖ kubectl configured and connected"

      - name: Create Kubernetes secrets from GitHub secrets
        run: |
          export KUBECONFIG=${{ github.workspace }}/kubeconfig
          echo "üîê Creating Kubernetes secrets from GitHub secrets..."
          
          # Verify required secrets are available
          echo "üîç Verifying GitHub secrets..."
          REQUIRED_SECRETS="DB_PASSWORD DB_USERNAME DB_URL FRONTEND_API_URL"
          MISSING_SECRETS=""
          
          for secret in $REQUIRED_SECRETS; do
            SECRET_VALUE=""
            case $secret in
              "DB_PASSWORD") SECRET_VALUE="${{ secrets.DB_PASSWORD }}" ;;
              "DB_USERNAME") SECRET_VALUE="${{ secrets.DB_USERNAME }}" ;;
              "DB_URL") SECRET_VALUE="${{ secrets.DB_URL }}" ;;
              "FRONTEND_API_URL") SECRET_VALUE="${{ secrets.FRONTEND_API_URL }}" ;;
            esac
            
            if [ -z "$SECRET_VALUE" ]; then
              MISSING_SECRETS="$MISSING_SECRETS $secret"
            fi
          done
          
          if [ ! -z "$MISSING_SECRETS" ]; then
            echo "‚ùå Missing required secrets:$MISSING_SECRETS"
            echo "‚ö†Ô∏è Please configure these secrets in GitHub repository settings"
            exit 1
          fi
          
          echo "‚úÖ All required secrets are available"
          
          # Create database secrets (plain text - kubectl handles encoding)
          kubectl create secret generic tasklist-db-secrets \
            --from-literal=db-username="${{ secrets.DB_USERNAME }}" \
            --from-literal=db-password="${{ secrets.DB_PASSWORD }}" \
            --from-literal=db-url="${{ secrets.DB_URL }}" \
            --namespace=${NAMESPACE} \
            --dry-run=client -o yaml | kubectl apply -f -
          
          # Create application config secrets
          kubectl create secret generic tasklist-app-secrets \
            --from-literal=frontend-api-url="${{ secrets.FRONTEND_API_URL }}" \
            --namespace=${NAMESPACE} \
            --dry-run=client -o yaml | kubectl apply -f -
          
          echo "‚úÖ Kubernetes secrets created successfully"
          echo "üîç Verifying secrets were created..."
          if ! kubectl get secret tasklist-db-secrets -n ${{ env.NAMESPACE }} >/dev/null 2>&1; then
            echo "‚ùå Database secrets were not created"
            exit 1
          fi
          
          if ! kubectl get secret tasklist-app-secrets -n ${{ env.NAMESPACE }} >/dev/null 2>&1; then
            echo "‚ùå Application secrets were not created"
            exit 1
          fi
          
          echo "‚úÖ All secrets created successfully"
          kubectl get secrets -n ${{ env.NAMESPACE }}

      - name: Apply Kubernetes manifests
        run: |
          export KUBECONFIG=${{ github.workspace }}/kubeconfig
          echo "üöÄ Deploying application to Kubernetes..."
          
          # Verify k8s directory exists
          if [ ! -d "k8s/" ]; then
            echo "‚ùå k8s/ directory not found"
            exit 1
          fi
          
          echo "‚úÖ Kubernetes manifests found"
          
          # Apply manifests in order from your k8s directory structure
          echo "üîß Applying Kubernetes manifests in order..."
          
          # Apply namespace first (skip if already exists)
          kubectl apply -f k8s/namespace.yaml || echo "Namespace already exists or failed"
          
          # Apply service account and GHCR secret
          kubectl apply -f k8s/serviceaccount.yaml
          kubectl apply -f k8s/ghcr-secret.yaml
          
          # Apply database manifests
          kubectl apply -f k8s/postgres-manifests/
          
          # Apply API manifests
          kubectl apply -f k8s/api-manifests/
          
          # Apply frontend manifests
          kubectl apply -f k8s/frontend-manifests/
          
          # Apply ingress configurations
          kubectl apply -f k8s/ingress/
          
          # Apply monitoring configurations
          kubectl apply -f k8s/monitoring/
          
          # Apply microk8s specific configurations
          kubectl apply -f k8s/microk8s-hostpath-immediate.yaml
          
          echo "‚úÖ Kubernetes manifests applied"

      - name: Create ArgoCD application
        run: |
          export KUBECONFIG=${{ github.workspace }}/kubeconfig
          echo "üéØ Creating ArgoCD application from k8s/argocd directory..."
          
          # Apply all ArgoCD manifests from your argocd directory
          kubectl apply -f k8s/argocd/
          
          echo "‚úÖ ArgoCD applications created"

      - name: Verify deployment
        run: |
          export KUBECONFIG=${{ github.workspace }}/kubeconfig
          echo "üîç Verifying deployment..."
          
          # Check pod health
          kubectl get pods -n ${{ env.NAMESPACE }} -o wide
          
          # Check services
          kubectl get services -n ${{ env.NAMESPACE }}
          
          # Check ingress if available
          kubectl get ingress -n ${{ env.NAMESPACE }} || echo "No ingress resources found"
          
          # Show application URLs
          echo "üåê Application Access:"
          
          # Get NodePort services
          NODE_PORTS=$(kubectl get svc -n ${{ env.NAMESPACE }} --no-headers | grep NodePort | awk '{print $1 ":" $2 ":" $3}')
          if [ -n "$NODE_PORTS" ]; then
            echo "NodePort Services:"
            echo "$NODE_PORTS" | while IFS=':' read -r name type ports; do
              PORT=$(echo $ports | cut -d':' -f1)
              echo "  $name: http://$(hostname -I | awk '{print $1}'):$PORT"
            done
          fi
          
          # Get Ingress hosts
          INGRESS_HOSTS=$(kubectl get ingress -n ${{ env.NAMESPACE }} -o jsonpath='{.items[*].spec.rules[*].host}' 2>/dev/null || echo "")
          if [ -n "$INGRESS_HOSTS" ]; then
            echo "Ingress Hosts:"
            for host in $INGRESS_HOSTS; do
              echo "  http://$host"
            done
          fi

      - name: Troubleshooting info
        if: failure()
        run: |
          export KUBECONFIG=${{ github.workspace }}/kubeconfig
          echo "üîç Troubleshooting information..."
          
          # Check ArgoCD status
          echo "=== ArgoCD Status ==="
          kubectl get pods -n argocd
          kubectl get deployment -n argocd
          
          # Check application namespace
          echo "=== Application Namespace Status ==="
          kubectl get pods -n ${{ env.NAMESPACE }}
          kubectl get deployment -n ${{ env.NAMESPACE }}
          kubectl get events -n ${{ env.NAMESPACE }} --sort-by='.lastTimestamp' | tail -10
          
          # Check ArgoCD application logs
          echo "=== ArgoCD Application Logs ==="
          kubectl logs -n argocd deployment/argocd-application-controller --tail=20
          
          # Check resource usage
          echo "=== Resource Usage ==="
          kubectl top nodes 2>/dev/null || echo "Metrics server not available"
          kubectl top pods -n argocd 2>/dev/null || echo "Pod metrics not available"

      - name: Run smoke tests
        run: |
          export KUBECONFIG=${{ github.workspace }}/kubeconfig
          echo "üß™ Running smoke tests..."
          
          # Get application endpoint
          API_ENDPOINT=""
          
          # Try to get NodePort for backend service
          BACKEND_PORT=$(kubectl get svc tasklistapp-service -n ${{ env.NAMESPACE }} -o jsonpath='{.spec.ports[0].nodePort}' 2>/dev/null || echo "")
          if [ -n "$BACKEND_PORT" ]; then
            API_ENDPOINT="http://$(hostname -I | awk '{print $1}'):$BACKEND_PORT"
          fi
          
          # If no NodePort, try Ingress
          if [ -z "$API_ENDPOINT" ]; then
            INGRESS_HOST=$(kubectl get ingress -n ${{ env.NAMESPACE }} -o jsonpath='{.items[0].spec.rules[0].host}' 2>/dev/null || echo "")
            if [ -n "$INGRESS_HOST" ]; then
              API_ENDPOINT="http://$INGRESS_HOST"
            fi
          fi
          
          if [ -n "$API_ENDPOINT" ]; then
            echo "Testing endpoint: $API_ENDPOINT"
            
            # Test health endpoint
            if curl -f -s "$API_ENDPOINT/actuator/health" > /dev/null; then
              echo "‚úÖ Health check passed"
            else
              echo "‚ùå Health check failed"
              exit 1
            fi
            
            # Test API endpoint
            if curl -f -s "$API_ENDPOINT/api/tasks" > /dev/null; then
              echo "‚úÖ API endpoint test passed"
            else
              echo "‚ùå API endpoint test failed"
              exit 1
            fi
          else
            echo "‚ö†Ô∏è Could not determine API endpoint, skipping smoke tests"
          fi
