name: Deploy to Kubernetes

on:
  workflow_run:
    workflows: ["Deploy Infrastructure"]
    types:
      - completed
  workflow_dispatch:

# Sets permissions of the GITHUB_TOKEN to allow deployment
permissions:
  contents: read
  packages: read

env:
  KUBE_CONFIG: ${{ github.workspace }}/kubeconfig
  NAMESPACE: tasklistapp
  # Environment variables from GitHub secrets
  DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
  DB_USERNAME: ${{ secrets.DB_USERNAME }}
  DB_URL: ${{ secrets.DB_URL }}
  FRONTEND_API_URL: ${{ secrets.FRONTEND_API_URL }}

jobs:
  deploy:
    runs-on: [self-hosted, linux]
    env:
      KUBECONFIG: /home/siseko/microk8s-kubeconfig
      NAMESPACE: tasklist
      # Environment variables from GitHub secrets
      DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
      DB_USERNAME: ${{ secrets.DB_USERNAME }}
      DB_URL: ${{ secrets.DB_URL }}
      FRONTEND_API_URL: ${{ secrets.FRONTEND_API_URL }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Verify Fixed Kubeconfig
        run: |
          echo "üîç Checking fixed kubeconfig file..."
          
          # Check if fixed kubeconfig exists
          if [ -f "/home/siseko/microk8s-kubeconfig" ]; then
            echo "‚úÖ Fixed kubeconfig found"
            echo "üìã Kubeconfig content preview:"
            head -n 5 /home/siseko/microk8s-kubeconfig
            grep server /home/siseko/microk8s-kubeconfig
          else
            echo "‚ùå Fixed kubeconfig not found at /home/siseko/microk8s-kubeconfig"
            echo "üìÅ Available files in /home/siseko/:"
            ls -la /home/siseko/ | grep kubeconfig || echo "No kubeconfig files found"
            exit 1
          fi

      - name: Setup kubectl
        run: |
          if ! command -v kubectl &> /dev/null; then
            echo "kubectl not found, installing..."
            curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
            chmod +x kubectl
            sudo mv kubectl /usr/local/bin/
          fi
          
          # Test connection using fixed kubeconfig
          echo "üîç Testing kubeconfig connection..."
          kubectl --kubeconfig=/home/siseko/microk8s-kubeconfig get nodes
          kubectl --kubeconfig=/home/siseko/microk8s-kubeconfig cluster-info
          echo "‚úÖ kubectl configured and connected"

      - name: Create Kubernetes secrets from GitHub secrets
        run: |
          echo "üîê Creating Kubernetes secrets from GitHub secrets..."
          
          # Verify required secrets are available
          echo "üîç Verifying GitHub secrets..."
          REQUIRED_SECRETS="DB_PASSWORD DB_USERNAME DB_URL FRONTEND_API_URL"
          MISSING_SECRETS=""
          
          for secret in $REQUIRED_SECRETS; do
            SECRET_VALUE=""
            case $secret in
              "DB_PASSWORD") SECRET_VALUE="${{ secrets.DB_PASSWORD }}" ;;
              "DB_USERNAME") SECRET_VALUE="${{ secrets.DB_USERNAME }}" ;;
              "DB_URL") SECRET_VALUE="${{ secrets.DB_URL }}" ;;
              "FRONTEND_API_URL") SECRET_VALUE="${{ secrets.FRONTEND_API_URL }}" ;;
            esac
            
            if [ -z "$SECRET_VALUE" ]; then
              MISSING_SECRETS="$MISSING_SECRETS $secret"
            fi
          done
          
          if [ ! -z "$MISSING_SECRETS" ]; then
            echo "‚ùå Missing required secrets:$MISSING_SECRETS"
            echo "‚ö†Ô∏è Please configure these secrets in GitHub repository settings"
            exit 1
          fi
          
          echo "‚úÖ All required secrets are available"
          
          # Create database secrets (plain text - kubectl handles encoding)
          kubectl --kubeconfig=/home/siseko/microk8s-kubeconfig create secret generic tasklist-db-secrets \
            --from-literal=db-username="${{ secrets.DB_USERNAME }}" \
            --from-literal=db-password="${{ secrets.DB_PASSWORD }}" \
            --from-literal=db-url="${{ secrets.DB_URL }}" \
            --namespace=${NAMESPACE} \
            --dry-run=client -o yaml | kubectl --kubeconfig=/home/siseko/microk8s-kubeconfig apply -f -
          
          # Create application config secrets
          kubectl --kubeconfig=/home/siseko/microk8s-kubeconfig create secret generic tasklist-app-secrets \
            --from-literal=frontend-api-url="${{ secrets.FRONTEND_API_URL }}" \
            --namespace=${NAMESPACE} \
            --dry-run=client -o yaml | kubectl --kubeconfig=/home/siseko/microk8s-kubeconfig apply -f -
          
          echo "‚úÖ Kubernetes secrets created successfully"
          echo "üîç Verifying secrets were created..."
          if ! kubectl --kubeconfig=/home/siseko/microk8s-kubeconfig get secret tasklist-db-secrets -n ${{ env.NAMESPACE }} >/dev/null 2>&1; then
            echo "‚ùå Database secrets were not created"
            exit 1
          fi
          
          if ! kubectl --kubeconfig=/home/siseko/microk8s-kubeconfig get secret tasklist-app-secrets -n ${{ env.NAMESPACE }} >/dev/null 2>&1; then
            echo "‚ùå Application secrets were not created"
            exit 1
          fi
          
          echo "‚úÖ All secrets created successfully"
          kubectl get secrets -n ${{ env.NAMESPACE }}

      - name: Apply Kubernetes manifests
        run: |
          echo "üöÄ Deploying application to Kubernetes..."
          
          # Verify k8s directory exists
          if [ ! -d "k8s/" ]; then
            echo "‚ùå k8s/ directory not found"
            exit 1
          fi
          echo "‚úÖ Kubernetes manifests found"
          
          # Delete existing database deployment to fix immutable selector issue
          echo "üîß Deleting existing database deployment to fix selector issue..."
          kubectl --kubeconfig=/home/siseko/microk8s-kubeconfig delete deployment postgresdb-deployment -n ${{ env.NAMESPACE }} --ignore-not-found=true --force --grace-period=0 || true
          echo "‚úÖ Database deployment deletion attempted"
          
          echo "üîß Applying Kubernetes manifests in order..."
          
          # Apply namespace first (skip if already exists)
          kubectl --kubeconfig=/home/siseko/microk8s-kubeconfig apply -f k8s/namespace.yaml || echo "Namespace already exists or failed"
          
          # Apply service account and GHCR secret
          kubectl --kubeconfig=/home/siseko/microk8s-kubeconfig apply -f k8s/serviceaccount.yaml
          kubectl --kubeconfig=/home/siseko/microk8s-kubeconfig apply -f k8s/ghcr-secret.yaml
          
          # Apply database manifests
          kubectl --kubeconfig=/home/siseko/microk8s-kubeconfig apply -f k8s/postgres-manifests/
          
          # Apply API manifests
          kubectl --kubeconfig=/home/siseko/microk8s-kubeconfig apply -f k8s/api-manifests/
          
          # Apply frontend manifests
          kubectl --kubeconfig=/home/siseko/microk8s-kubeconfig apply -f k8s/frontend-manifests/
          
          # Apply ingress configurations
          kubectl --kubeconfig=/home/siseko/microk8s-kubeconfig apply -f k8s/ingress/
          
          # Apply monitoring configurations
          kubectl --kubeconfig=/home/siseko/microk8s-kubeconfig apply -f k8s/monitoring/
          
          # Apply microk8s specific configurations
          kubectl --kubeconfig=/home/siseko/microk8s-kubeconfig apply -f k8s/microk8s-hostpath-immediate.yaml
          
          echo "‚úÖ Kubernetes manifests applied"

      - name: Create ArgoCD application
        run: |
          echo "üéØ Creating ArgoCD application from k8s/argocd directory..."
          
          # Apply all ArgoCD manifests from your argocd directory
          kubectl --kubeconfig=/home/siseko/microk8s-kubeconfig apply -f k8s/argocd/
          
          echo "‚úÖ ArgoCD applications created"

      - name: Verify deployment
        run: |
          echo "üîç Verifying deployment..."
          
          # Check all pods in namespace
          kubectl --kubeconfig=/home/siseko/microk8s-kubeconfig get pods -n ${{ env.NAMESPACE }}
          
          # Check services
          kubectl --kubeconfig=/home/siseko/microk8s-kubeconfig get services -n ${{ env.NAMESPACE }}
          
          # Check deployments
          kubectl --kubeconfig=/home/siseko/microk8s-kubeconfig get deployments -n ${{ env.NAMESPACE }}
          
          echo "‚úÖ Deployment verification completed"
          
          # Show application URLs
          echo "üåê Application Access:"
          
          # Get NodePort services
          NODE_PORTS=$(kubectl --kubeconfig=/home/siseko/microk8s-kubeconfig get svc -n ${{ env.NAMESPACE }} --no-headers | grep NodePort | awk '{print $1 ":" $2 ":" $3}')
          if [ -n "$NODE_PORTS" ]; then
            echo "NodePort Services:"
            echo "$NODE_PORTS" | while IFS=':' read -r name type ports; do
              PORT=$(echo $ports | cut -d':' -f1)
              echo "  $name: http://$(hostname -I | awk '{print $1}'):$PORT"
            done
          fi
          
          # Get Ingress hosts
          INGRESS_HOSTS=$(kubectl --kubeconfig=/home/siseko/microk8s-kubeconfig get ingress -n ${{ env.NAMESPACE }} -o jsonpath='{.items[*].spec.rules[*].host}' 2>/dev/null || echo "")
          if [ -n "$INGRESS_HOSTS" ]; then
            echo "Ingress Hosts:"
            for host in $INGRESS_HOSTS; do
              echo "  http://$host"
            done
          fi

      - name: Troubleshooting info
        if: failure()
        run: |
          echo "üîç Troubleshooting information..."
          
          # Check cluster status
          kubectl --kubeconfig=/home/siseko/microk8s-kubeconfig cluster-info
          
          # Check nodes
          kubectl --kubeconfig=/home/siseko/microk8s-kubeconfig get nodes
          
          # Check all namespaces
          kubectl --kubeconfig=/home/siseko/microk8s-kubeconfig get namespaces
          
          # Check events in namespace
          kubectl --kubeconfig=/home/siseko/microk8s-kubeconfig get events -n ${{ env.NAMESPACE }} --sort-by='.lastTimestamp'
          
          # Check pod logs for errors
          echo "üìã Pod logs:"
          kubectl --kubeconfig=/home/siseko/microk8s-kubeconfig get pods -n ${{ env.NAMESPACE }} -o wide
          for pod in $(kubectl --kubeconfig=/home/siseko/microk8s-kubeconfig get pods -n ${{ env.NAMESPACE }} -o jsonpath='{.items[*].metadata.name}' 2>/dev/null || echo ""); do
            echo "--- Logs for pod: $pod ---"
            kubectl --kubeconfig=/home/siseko/microk8s-kubeconfig logs -n ${{ env.NAMESPACE }} $pod --tail=10 || echo "Could not get logs for $pod"
          done

      - name: Run smoke tests
        run: |
          echo "üß™ Running smoke tests..."
          
          # Wait for pods to be ready
          echo "‚è≥ Waiting for pods to be ready..."
          kubectl --kubeconfig=/home/siseko/microk8s-kubeconfig wait --for=condition=ready pod -l app=tasklistapp -n ${{ env.NAMESPACE }} --timeout=300s || true
          kubectl --kubeconfig=/home/siseko/microk8s-kubeconfig wait --for=condition=ready pod -l app=tasklist-postgresql -n ${{ env.NAMESPACE }} --timeout=300s || true
          
          # Get API endpoint
          API_ENDPOINT=""
          
          # Try NodePort first
          NODEPORT=$(kubectl --kubeconfig=/home/siseko/microk8s-kubeconfig get svc tasklistapp-service -n ${{ env.NAMESPACE }} -o jsonpath='{.spec.ports[?(@.name=="http")].nodePort}' 2>/dev/null || echo "")
          if [ -n "$NODEPORT" ]; then
            API_ENDPOINT="http://$(hostname -I | awk '{print $1}'):$NODEPORT/api"
          else
            # Try Ingress
            INGRESS_HOST=$(kubectl --kubeconfig=/home/siseko/microk8s-kubeconfig get ingress tasklist-ingress -n ${{ env.NAMESPACE }} -o jsonpath='{.spec.rules[0].host}' 2>/dev/null || echo "")
            if [ -n "$INGRESS_HOST" ]; then
              API_ENDPOINT="http://$INGRESS_HOST/api"
            fi
          fi
          
          if [ -n "$API_ENDPOINT" ]; then
            echo "üåê Testing API endpoint: $API_ENDPOINT"
            
            # Test health endpoint
            echo "üîç Testing health endpoint..."
            if curl -f -s "$API_ENDPOINT/../actuator/health" >/dev/null 2>&1; then
              echo "‚úÖ Health check passed"
            else
              echo "‚ö†Ô∏è Health check failed"
            fi
            
            # Test tasks endpoint
            echo "üîç Testing tasks endpoint..."
            if curl -f -s "$API_ENDPOINT/tasks" >/dev/null 2>&1; then
              echo "‚úÖ Tasks endpoint accessible"
            else
              echo "‚ö†Ô∏è Tasks endpoint not accessible"
            fi
            
            # Create test task
            echo "üîç Creating test task..."
            TEST_TASK=$(curl -s -X POST "$API_ENDPOINT/tasks" \
              -H "Content-Type: application/json" \
              -d '{"title":"Smoke Test Task","description":"Created during smoke test","completed":false}' 2>/dev/null || echo "")
            
            if [ -n "$TEST_TASK" ]; then
              echo "‚úÖ Test task created successfully"
            else
              echo "‚ö†Ô∏è Failed to create test task"
            fi
          else
            echo "‚ö†Ô∏è Could not determine API endpoint, skipping smoke tests"
          fi
