name: Deploy Infrastructure

on:
  workflow_dispatch:
  workflow_run:
    workflows: ["Version Management - Tag Images"]
    types: [completed]

jobs:
  deploy-infrastructure:
    name: Deploy Infrastructure
    runs-on: [self-hosted, linux]

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up environment
        run: |
          # Create target directory
          echo ${{ secrets.SUDO_PASSWORD }} | sudo -S mkdir -p /opt/tasklistapp
          echo ${{ secrets.SUDO_PASSWORD }} | sudo -S chown -R $USER:$USER /opt/tasklistapp
          
          # Install required packages
          echo ${{ secrets.SUDO_PASSWORD }} | sudo -S apt-get update -y
          echo ${{ secrets.SUDO_PASSWORD }} | sudo -S apt-get install -y \
            apt-transport-https \
            apache2-utils \
            ca-certificates \
            curl \
            gnupg \
            lsb-release \
            jq \
            make \
            git

      - name: Install Docker and Docker Compose
        run: |
          if command -v docker &> /dev/null; then
            echo "‚úÖ Docker is already installed, skipping installation"
            docker --version
          else
            echo "üîß Installing Docker..."
            curl -fsSL https://download.docker.com/linux/ubuntu/gpg | gpg --dearmor -o /tmp/docker-archive-keyring.gpg
            echo ${{ secrets.SUDO_PASSWORD }} | sudo -S cp /tmp/docker-archive-keyring.gpg /usr/share/keyrings/
            echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
            echo ${{ secrets.SUDO_PASSWORD }} | sudo -S apt-get update -y
            echo ${{ secrets.SUDO_PASSWORD }} | sudo -S apt-get install -y docker-ce docker-ce-cli containerd.io
            echo "‚úÖ Docker installed successfully"
          fi

          if command -v docker-compose &> /dev/null; then
            echo "‚úÖ Docker Compose is already installed, skipping installation"
            docker-compose --version
          else
            echo "üîß Installing Docker Compose..."
            curl -L "https://github.com/docker/compose/releases/download/v2.20.2/docker-compose-$(uname -s)-$(uname -m)" -o /tmp/docker-compose
            echo ${{ secrets.SUDO_PASSWORD }} | sudo -S mv /tmp/docker-compose /usr/local/bin/
            echo ${{ secrets.SUDO_PASSWORD }} | sudo -S chmod +x /usr/local/bin/docker-compose
            echo "‚úÖ Docker Compose installed successfully"
          fi

          echo ${{ secrets.SUDO_PASSWORD }} | sudo -S usermod -aG docker $USER
          newgrp docker
          echo ${{ secrets.SUDO_PASSWORD }} | sudo -S systemctl enable docker
          echo ${{ secrets.SUDO_PASSWORD }} | sudo -S systemctl start docker
          docker --version
          docker-compose --version

      - name: Install MicroK8s and required tools
        run: |
          if command -v microk8s &> /dev/null; then
            echo "‚úÖ MicroK8s is already installed"
          else
            echo "üîß Installing MicroK8s..."
            echo ${{ secrets.SUDO_PASSWORD }} | sudo -S snap install microk8s --classic --channel=1.27/stable
            echo "‚úÖ MicroK8s installed successfully"
          fi

          if command -v kubectl &> /dev/null; then
            echo "‚úÖ kubectl is already installed"
            kubectl version --client
          else
            echo "üîß Installing kubectl..."
            echo ${{ secrets.SUDO_PASSWORD }} | sudo -S snap install kubectl --classic
            echo "‚úÖ kubectl installed successfully"
          fi

          if command -v jmeter &> /dev/null; then
            echo "‚úÖ JMeter is already installed"
          else
            echo "üîß Installing JMeter and additional tools..."
            echo ${{ secrets.SUDO_PASSWORD }} | sudo -S apt-get update
            echo ${{ secrets.SUDO_PASSWORD }} | sudo -S apt-get install -y jmeter jq tree htop apache2-utils
            echo "‚úÖ JMeter installed"
          fi

          echo ${{ secrets.SUDO_PASSWORD }} | sudo -S usermod -a -G microk8s $USER
          echo ${{ secrets.SUDO_PASSWORD }} | sudo -S chown -f -R $USER ~/.kube
          microk8s status --wait-ready

          ADDONS="dns storage ingress dashboard metrics-server registry"
          for addon in $ADDONS; do
            if microk8s status | grep -q "$addon: enabled"; then
              echo "‚úÖ $addon already enabled"
            else
              echo ${{ secrets.SUDO_PASSWORD }} | sudo -S microk8s enable $addon
            fi
          done

          microk8s kubectl wait --for=condition=available --timeout=300s deployment -n kube-system --all
          mkdir -p $HOME/.kube
          microk8s config > $HOME/.kube/config
          chmod 600 $HOME/.kube/config
          if ! grep -q 'alias kubectl="microk8s kubectl"' ~/.bashrc; then
            echo 'alias kubectl="microk8s kubectl"' >> ~/.bashrc
          fi
          source ~/.bashrc
          microk8s kubectl cluster-info
          microk8s kubectl get nodes --all-namespaces

      - name: Generate Fixed Kubeconfig
        run: |
          echo "üîß Generating fixed kubeconfig with localhost..."
          
          # Generate kubeconfig to fixed location
          microk8s config > /home/siseko/microk8s-kubeconfig
          
          # Force server to localhost (stable, never changes)
          sed -i 's|server: https://.*:16443|server: https://127.0.0.1:16443|' /home/siseko/microk8s-kubeconfig
          
          # Verify the change
          echo "‚úÖ Kubeconfig server address:"
          grep server /home/siseko/microk8s-kubeconfig
          
          # Set proper permissions
          chmod 644 /home/siseko/microk8s-kubeconfig
          
          # Copy to workspace for artifact upload
          cp /home/siseko/microk8s-kubeconfig ${{ github.workspace }}/kubeconfig
        
      - name: Test Fixed Kubeconfig Connection
        run: |
          echo "üîç Testing fixed kubeconfig connection..."
          
          # Test connection using fixed path
          kubectl --kubeconfig=/home/siseko/microk8s-kubeconfig get nodes
          kubectl --kubeconfig=/home/siseko/microk8s-kubeconfig cluster-info
          echo "‚úÖ Fixed kubeconfig connection successful"

      - name: Install and Configure ArgoCD
        run: |
          echo "üîÑ Installing ArgoCD..."
          
          # Install ArgoCD using fixed kubeconfig if not already installed
          if ! kubectl --kubeconfig=/home/siseko/microk8s-kubeconfig get namespace argocd >/dev/null 2>&1; then
            kubectl --kubeconfig=/home/siseko/microk8s-kubeconfig create namespace argocd
            kubectl --kubeconfig=/home/siseko/microk8s-kubeconfig apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml
          else
            echo "üîÅ ArgoCD already installed ‚Äî skipping re-install"
          fi

      - name: Apply Fixed ArgoCD Admin Password
        run: |
          echo "üîê Applying consistent ArgoCD admin password..."

          # Base64 bcrypt hash for password: admin
          FIXED_HASH="JDJiJDEwJEtNQlNlc0N1Z29QZUQ3UTdqUGN5a082TVUuS0dhWFdWRWNaMjlQaVYuY3k3NXYxSE54cnl1"

          # Patch secret (idempotent ‚Äî safe to run every workflow)
          kubectl --kubeconfig=/home/siseko/microk8s-kubeconfig -n argocd patch secret argocd-secret \
            -p "{\"data\": {\"admin.password\": \"${FIXED_HASH}\", \"admin.passwordMtime\": \"$(date +%s | base64)\"}}"

          echo "‚úÖ ArgoCD admin password set to: admin"

      - name: Wait for ArgoCD to be ready
        run: |
          echo "‚è≥ Waiting for ArgoCD to be ready..."
          
          # Wait for deployments to be created first
          echo "üîç Waiting for deployments to be created..."
          for i in {1..10}; do
            if kubectl --kubeconfig=/home/siseko/microk8s-kubeconfig get statefulset argocd-application-controller -n argocd >/dev/null 2>&1; then
              echo "‚úÖ argocd-application-controller found"
              break
            else
              echo "‚è≥ Waiting for argocd-application-controller... ($i/10)"
              sleep 15
            fi
          done
          
          # Check if deployment exists after waiting
          if ! kubectl --kubeconfig=/home/siseko/microk8s-kubeconfig get statefulset argocd-application-controller -n argocd >/dev/null 2>&1; then
            echo "‚ùå argocd-application-controller statefulset not found after waiting"
            echo "üîç Troubleshooting information:"
            echo "Available deployments in argocd namespace:"
            kubectl --kubeconfig=/home/siseko/microk8s-kubeconfig get deployments -n argocd || echo "No deployments found"
            echo "All resources in argocd namespace:"
            kubectl --kubeconfig=/home/siseko/microk8s-kubeconfig get all -n argocd || echo "No resources found"
            echo "Pods in argocd namespace:"
            kubectl --kubeconfig=/home/siseko/microk8s-kubeconfig get pods -n argocd || echo "No pods found"
            echo "Events in argocd namespace:"
            kubectl --kubeconfig=/home/siseko/microk8s-kubeconfig get events -n argocd --sort-by='.lastTimestamp' || echo "No events found"
            exit 1
          fi
          
          # Now wait for deployments to be ready with timeout
          echo "üîç Waiting for deployments to be ready..."
          kubectl --kubeconfig=/home/siseko/microk8s-kubeconfig wait --for=condition=available deployment/argocd-server -n argocd --timeout=300s || {
            echo "‚ùå argocd-server failed to become available"
            kubectl --kubeconfig=/home/siseko/microk8s-kubeconfig describe deployment argocd-server -n argocd
            kubectl --kubeconfig=/home/siseko/microk8s-kubeconfig get pods -n argocd -l app.kubernetes.io/name=argocd-server
            kubectl --kubeconfig=/home/siseko/microk8s-kubeconfig logs -n argocd -l app.kubernetes.io/name=argocd-server --tail=20
            exit 1
          }
          
          kubectl --kubeconfig=/home/siseko/microk8s-kubeconfig wait --for=condition=available deployment/argocd-repo-server -n argocd --timeout=300s || {
            echo "‚ùå argocd-repo-server failed to become available"
            kubectl --kubeconfig=/home/siseko/microk8s-kubeconfig describe deployment argocd-repo-server -n argocd
            kubectl --kubeconfig=/home/siseko/microk8s-kubeconfig get pods -n argocd -l app.kubernetes.io/name=argocd-repo-server
            kubectl --kubeconfig=/home/siseko/microk8s-kubeconfig logs -n argocd -l app.kubernetes.io/name=argocd-repo-server --tail=20
            exit 1
          }
          
          kubectl --kubeconfig=/home/siseko/microk8s-kubeconfig wait --for=condition=ready pod -l app.kubernetes.io/name=argocd-application-controller -n argocd --timeout=300s || {
            echo "‚ùå argocd-application-controller failed to become ready"
            kubectl --kubeconfig=/home/siseko/microk8s-kubeconfig describe statefulset argocd-application-controller -n argocd
            kubectl --kubeconfig=/home/siseko/microk8s-kubeconfig get pods -n argocd -l app.kubernetes.io/name=argocd-application-controller
            kubectl --kubeconfig=/home/siseko/microk8s-kubeconfig logs -n argocd -l app.kubernetes.io/name=argocd-application-controller --tail=20
            exit 1
          }
          
          # Configure ArgoCD with NodePort for external access
          kubectl --kubeconfig=/home/siseko/microk8s-kubeconfig patch svc argocd-server -n argocd -p '{"spec":{"type":"NodePort","ports":[{"name":"http","port":80,"targetPort":8080,"nodePort":30007},{"name":"https","port":443,"targetPort":8080,"nodePort":30008}]}}'
          
          # Get and print default ArgoCD password
          echo "üîê Getting default ArgoCD password..."
          ARGOCD_PASSWORD=$(kubectl --kubeconfig=/home/siseko/microk8s-kubeconfig -n argocd get secret argocd-secret -o jsonpath="{.data.admin.password}" | base64 -d)
          echo "‚ÑπÔ∏è Use this password for first login, then change it in ArgoCD settings"
          echo "‚úÖ ArgoCD installed and configured"
          echo "üîó ArgoCD will be available at: http://$(hostname -I | awk '{print $1}'):30007"
          echo "üë§ Username: admin"
          echo "üîë Password: $ARGOCD_PASSWORD"
          
          # Create application namespace
          if kubectl --kubeconfig=/home/siseko/microk8s-kubeconfig get namespace tasklistapp >/dev/null 2>&1; then
            echo "‚úÖ Application namespace already exists"
          else
            echo "üîß Creating application namespace..."
            kubectl --kubeconfig=/home/siseko/microk8s-kubeconfig create namespace tasklistapp
          fi
          
          echo "‚úÖ Infrastructure setup completed"

      - name: Create ArgoCD Application
        run: |
          echo "üéØ Creating ArgoCD application for tasklistapp..."
          
          # Apply ArgoCD application manifest with fixed kubeconfig
          kubectl --kubeconfig=/home/siseko/microk8s-kubeconfig apply -f - << 'EOF'
          apiVersion: argoproj.io/v1alpha1
          kind: Application
          metadata:
            name: tasklistapp
            namespace: argocd
          spec:
            project: default
            source:
              repoURL: https://github.com/SLMakomazi/TasklistApp.git
              targetRevision: HEAD
              path: k8s
            destination:
              server: https://kubernetes.default.svc
              namespace: tasklistapp
            syncPolicy:
              automated:
                prune: true
                selfHeal: true
              syncOptions:
                - CreateNamespace=true
          EOF
          
          echo "‚úÖ ArgoCD application created"
          echo "üîó ArgoCD will automatically sync the k8s directory"

  performance-tests:
    name: Run JMeter Performance Tests
    runs-on: [self-hosted, linux]
    needs: deploy-infrastructure
    if: always()  # Run even if previous steps failed

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup JMeter Test Plan
        run: |
          echo "üìÇ Setting up JMeter test plan..."
          
          # Create directory structure if it doesn't exist
          mkdir -p ~/jmeter/test-plans
          
          # Copy test plan from repository root to home directory
          if [ -f "${{ github.workspace }}/jmeter/test-plans/api-load-test.jmx" ]; then
            mkdir -p ~/jmeter/test-plans
            cp "${{ github.workspace }}/jmeter/test-plans/api-load-test.jmx" ~/jmeter/test-plans/
            echo "‚úÖ Copied JMeter test plan from repository to ~/jmeter/test-plans/"
          else
            echo "‚ùå JMeter test plan not found in repository!"
            echo "Expected path: ${{ github.workspace }}/jmeter/test-plans/api-load-test.jmx"
            exit 1
          fi

      - name: Run JMeter Test Plan
        run: |
          echo "üöÄ Running JMeter tests..."
          
          # Create results directory in home folder
          RESULTS_DIR=~/tasklistapp-performance
          mkdir -p "$RESULTS_DIR"
          cd "$RESULTS_DIR"
          
          # Get node IP
          NODE_IP=$(hostname -I | awk '{print $1}')
          NODE_PORT=30080
          
          echo "üîç Testing endpoint: http://${NODE_IP}:${NODE_PORT}/api/tasks"
          
          # Wait for service to be available
          until curl -s "http://${NODE_IP}:${NODE_PORT}/api/tasks" >/dev/null; do
            echo "‚è≥ Waiting for application to be ready..."
            sleep 5
          done
          
          # Run JMeter test
          jmeter -n \
            -t ~/jmeter/test-plans/api-load-test.jmx \
            -J HOST=${NODE_IP} \
            -J PORT=${NODE_PORT} \
            -J PROTOCOL=http \
            -l results.jtl \
            -e -o report
          
          echo "‚úÖ JMeter test execution complete"
          echo "üìÅ HTML Report generated at: $RESULTS_DIR/report"
          
          # List files for debugging
          echo "üìÇ Contents of $RESULTS_DIR:"
          ls -la "$RESULTS_DIR"
          echo "üìÇ Contents of $RESULTS_DIR/report:"
          ls -la "$RESULTS_DIR/report" || echo "‚ö†Ô∏è Report directory not found"

      - name: Upload HTML Performance Report
        uses: actions/upload-artifact@v4
        with:
          name: jmeter-performance-report
          path: ~/tasklistapp-performance/report
          retention-days: 5
          if-no-files-found: error

      - name: Upload JMeter Results
        uses: actions/upload-artifact@v4
        with:
          name: jmeter-raw-results
          path: ~/tasklistapp-performance/results.jtl
          retention-days: 5
          if-no-files-found: error

  # Original upload kubeconfig job
  upload-kubeconfig:
    name: Upload Kubeconfig
    runs-on: [self-hosted, linux]
    needs: deploy-infrastructure
    if: always()

    steps:
      - name: Upload kubeconfig
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: kubeconfig
          path: /home/siseko/microk8s-kubeconfig
          if-no-files-found: error
          retention-days: 1
