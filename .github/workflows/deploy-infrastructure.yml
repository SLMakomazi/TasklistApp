name: Deploy Infrastructure

on:
  workflow_dispatch:
  workflow_run:
    workflows: ["Version Management - Tag Images"]
    types: [completed]

jobs:
  deploy-infrastructure:
    name: Deploy Infrastructure
    runs-on: [self-hosted, linux]

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up environment
        run: |
          # Create target directory
          echo ${{ secrets.SUDO_PASSWORD }} | sudo -S mkdir -p /opt/tasklistapp
          echo ${{ secrets.SUDO_PASSWORD }} | sudo -S chown -R $USER:$USER /opt/tasklistapp
          
          # Install required packages
          echo ${{ secrets.SUDO_PASSWORD }} | sudo -S apt-get update -y
          echo ${{ secrets.SUDO_PASSWORD }} | sudo -S apt-get install -y \
            apt-transport-https \
            apache2-utils \
            ca-certificates \
            curl \
            gnupg \
            lsb-release \
            jq \
            make \
            git

      - name: Install Docker and Docker Compose
        run: |
          if command -v docker &> /dev/null; then
            echo "âœ… Docker is already installed, skipping installation"
            docker --version
          else
            echo "ðŸ”§ Installing Docker..."
            curl -fsSL https://download.docker.com/linux/ubuntu/gpg | gpg --dearmor -o /tmp/docker-archive-keyring.gpg
            echo ${{ secrets.SUDO_PASSWORD }} | sudo -S cp /tmp/docker-archive-keyring.gpg /usr/share/keyrings/
            echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
            echo ${{ secrets.SUDO_PASSWORD }} | sudo -S apt-get update -y
            echo ${{ secrets.SUDO_PASSWORD }} | sudo -S apt-get install -y docker-ce docker-ce-cli containerd.io
            echo "âœ… Docker installed successfully"
          fi

          if command -v docker-compose &> /dev/null; then
            echo "âœ… Docker Compose is already installed, skipping installation"
            docker-compose --version
          else
            echo "ðŸ”§ Installing Docker Compose..."
            curl -L "https://github.com/docker/compose/releases/download/v2.20.2/docker-compose-$(uname -s)-$(uname -m)" -o /tmp/docker-compose
            echo ${{ secrets.SUDO_PASSWORD }} | sudo -S mv /tmp/docker-compose /usr/local/bin/
            echo ${{ secrets.SUDO_PASSWORD }} | sudo -S chmod +x /usr/local/bin/docker-compose
            echo "âœ… Docker Compose installed successfully"
          fi

          echo ${{ secrets.SUDO_PASSWORD }} | sudo -S usermod -aG docker $USER
          newgrp docker
          echo ${{ secrets.SUDO_PASSWORD }} | sudo -S systemctl enable docker
          echo ${{ secrets.SUDO_PASSWORD }} | sudo -S systemctl start docker
          docker --version
          docker-compose --version

      - name: Install MicroK8s and required tools
        run: |
          if command -v microk8s &> /dev/null; then
            echo "âœ… MicroK8s is already installed"
          else
            echo "ðŸ”§ Installing MicroK8s..."
            echo ${{ secrets.SUDO_PASSWORD }} | sudo -S snap install microk8s --classic --channel=1.27/stable
            echo "âœ… MicroK8s installed successfully"
          fi

          if command -v kubectl &> /dev/null; then
            echo "âœ… kubectl is already installed"
            kubectl version --client
          else
            echo "ðŸ”§ Installing kubectl..."
            echo ${{ secrets.SUDO_PASSWORD }} | sudo -S snap install kubectl --classic
            echo "âœ… kubectl installed successfully"
          fi

          if command -v jmeter &> /dev/null; then
            echo "âœ… JMeter is already installed"
          else
            echo "ðŸ”§ Installing JMeter and additional tools..."
            echo ${{ secrets.SUDO_PASSWORD }} | sudo -S apt-get update
            echo ${{ secrets.SUDO_PASSWORD }} | sudo -S apt-get install -y jmeter jq tree htop apache2-utils
            echo "âœ… JMeter installed"
          fi

          echo ${{ secrets.SUDO_PASSWORD }} | sudo -S usermod -a -G microk8s $USER
          echo ${{ secrets.SUDO_PASSWORD }} | sudo -S chown -f -R $USER ~/.kube
          microk8s status --wait-ready

          ADDONS="dns storage ingress dashboard metrics-server registry"
          for addon in $ADDONS; do
            if microk8s status | grep -q "$addon: enabled"; then
              echo "âœ… $addon already enabled"
            else
              echo ${{ secrets.SUDO_PASSWORD }} | sudo -S microk8s enable $addon
            fi
          done

          microk8s kubectl wait --for=condition=available --timeout=300s deployment -n kube-system --all
          mkdir -p $HOME/.kube
          microk8s config > $HOME/.kube/config
          chmod 600 $HOME/.kube/config
          if ! grep -q 'alias kubectl="microk8s kubectl"' ~/.bashrc; then
            echo 'alias kubectl="microk8s kubectl"' >> ~/.bashrc
          fi
          source ~/.bashrc
          microk8s kubectl cluster-info
          microk8s kubectl get nodes --all-namespaces

      - name: Generate Fixed Kubeconfig
        run: |
          echo "ðŸ”§ Generating fixed kubeconfig with localhost..."
          
          # Generate kubeconfig to fixed location
          microk8s config > /home/siseko/microk8s-kubeconfig
          
          # Force server to localhost (stable, never changes)
          sed -i 's|server: https://.*:16443|server: https://127.0.0.1:16443|' /home/siseko/microk8s-kubeconfig
          
          # Verify the change
          echo "âœ… Kubeconfig server address:"
          grep server /home/siseko/microk8s-kubeconfig
          
          # Set proper permissions
          chmod 644 /home/siseko/microk8s-kubeconfig
          
          # Copy to workspace for artifact upload
          cp /home/siseko/microk8s-kubeconfig ${{ github.workspace }}/kubeconfig
        
      - name: Test Fixed Kubeconfig Connection
        run: |
          echo "ðŸ” Testing fixed kubeconfig connection..."
          
          # Test connection using fixed path
          kubectl --kubeconfig=/home/siseko/microk8s-kubeconfig get nodes
          kubectl --kubeconfig=/home/siseko/microk8s-kubeconfig cluster-info
          echo "âœ… Fixed kubeconfig connection successful"

      - name: Install and Configure ArgoCD
        run: |
          echo "ðŸ”„ Installing ArgoCD..."
          
          # Install ArgoCD using fixed kubeconfig
          kubectl --kubeconfig=/home/siseko/microk8s-kubeconfig create namespace argocd --dry-run=client -o yaml | kubectl --kubeconfig=/home/siseko/microk8s-kubeconfig apply -f -
          kubectl --kubeconfig=/home/siseko/microk8s-kubeconfig apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml

      - name: Wait for ArgoCD to be ready
        run: |
          echo "â³ Waiting for ArgoCD to be ready..."
          
          # Wait for deployments to be created first
          echo "ðŸ” Waiting for deployments to be created..."
          for i in {1..10}; do
            if kubectl --kubeconfig=/home/siseko/microk8s-kubeconfig get statefulset argocd-application-controller -n argocd >/dev/null 2>&1; then
              echo "âœ… argocd-application-controller found"
              break
            else
              echo "â³ Waiting for argocd-application-controller... ($i/10)"
              sleep 15
            fi
          done
          
          # Check if deployment exists after waiting
          if ! kubectl --kubeconfig=/home/siseko/microk8s-kubeconfig get statefulset argocd-application-controller -n argocd >/dev/null 2>&1; then
            echo "âŒ argocd-application-controller statefulset not found after waiting"
            echo "ðŸ” Troubleshooting information:"
            echo "Available deployments in argocd namespace:"
            kubectl --kubeconfig=/home/siseko/microk8s-kubeconfig get deployments -n argocd || echo "No deployments found"
            echo "All resources in argocd namespace:"
            kubectl --kubeconfig=/home/siseko/microk8s-kubeconfig get all -n argocd || echo "No resources found"
            echo "Pods in argocd namespace:"
            kubectl --kubeconfig=/home/siseko/microk8s-kubeconfig get pods -n argocd || echo "No pods found"
            echo "Events in argocd namespace:"
            kubectl --kubeconfig=/home/siseko/microk8s-kubeconfig get events -n argocd --sort-by='.lastTimestamp' || echo "No events found"
            exit 1
          fi
          
          # Now wait for deployments to be ready with timeout
          echo "ðŸ” Waiting for deployments to be ready..."
          kubectl --kubeconfig=/home/siseko/microk8s-kubeconfig wait --for=condition=available deployment/argocd-server -n argocd --timeout=300s || {
            echo "âŒ argocd-server failed to become available"
            kubectl --kubeconfig=/home/siseko/microk8s-kubeconfig describe deployment argocd-server -n argocd
            kubectl --kubeconfig=/home/siseko/microk8s-kubeconfig get pods -n argocd -l app.kubernetes.io/name=argocd-server
            kubectl --kubeconfig=/home/siseko/microk8s-kubeconfig logs -n argocd -l app.kubernetes.io/name=argocd-server --tail=20
            exit 1
          }
          
          kubectl --kubeconfig=/home/siseko/microk8s-kubeconfig wait --for=condition=available deployment/argocd-repo-server -n argocd --timeout=300s || {
            echo "âŒ argocd-repo-server failed to become available"
            kubectl --kubeconfig=/home/siseko/microk8s-kubeconfig describe deployment argocd-repo-server -n argocd
            kubectl --kubeconfig=/home/siseko/microk8s-kubeconfig get pods -n argocd -l app.kubernetes.io/name=argocd-repo-server
            kubectl --kubeconfig=/home/siseko/microk8s-kubeconfig logs -n argocd -l app.kubernetes.io/name=argocd-repo-server --tail=20
            exit 1
          }
          
          kubectl --kubeconfig=/home/siseko/microk8s-kubeconfig wait --for=condition=ready pod -l app.kubernetes.io/name=argocd-application-controller -n argocd --timeout=300s || {
            echo "âŒ argocd-application-controller failed to become ready"
            kubectl --kubeconfig=/home/siseko/microk8s-kubeconfig describe statefulset argocd-application-controller -n argocd
            kubectl --kubeconfig=/home/siseko/microk8s-kubeconfig get pods -n argocd -l app.kubernetes.io/name=argocd-application-controller
            kubectl --kubeconfig=/home/siseko/microk8s-kubeconfig logs -n argocd -l app.kubernetes.io/name=argocd-application-controller --tail=20
            exit 1
          }
          
          # Configure ArgoCD with NodePort for external access
          kubectl --kubeconfig=/home/siseko/microk8s-kubeconfig patch svc argocd-server -n argocd -p '{"spec":{"type":"NodePort","ports":[{"name":"http","port":80,"targetPort":8080,"nodePort":30007},{"name":"https","port":443,"targetPort":8080,"nodePort":30008}]}}'
          
          
          # Set ArgoCD admin password using plain text 
          kubectl --kubeconfig=/home/siseko/microk8s-kubeconfig -n argocd patch secret argocd-secret \
            -p '{"stringData": {"admin.password": "admin123", "admin.passwordMtime": "'$(date +%s)'"}}'
          
          echo "âœ… ArgoCD installed and configured"
          echo "ðŸ”— ArgoCD will be available at: http://$(hostname -I | awk '{print $1}'):30007"
          echo "ðŸ‘¤ Username: admin"
          echo "ðŸ”‘ Password: admin123"
          
          # Create application namespace
          if kubectl --kubeconfig=/home/siseko/microk8s-kubeconfig get namespace tasklist >/dev/null 2>&1; then
            echo "âœ… Application namespace already exists"
          else
            echo "ðŸ”§ Creating application namespace..."
            kubectl --kubeconfig=/home/siseko/microk8s-kubeconfig create namespace tasklist
          fi
          
          echo "âœ… Infrastructure setup completed"

      - name: Create ArgoCD Application
        run: |
          echo "ðŸŽ¯ Creating ArgoCD application for tasklist-app..."
          
          # Apply ArgoCD application manifest with fixed kubeconfig
          kubectl --kubeconfig=/home/siseko/microk8s-kubeconfig apply -f - << 'EOF'
          apiVersion: argoproj.io/v1alpha1
          kind: Application
          metadata:
            name: tasklist-app
            namespace: argocd
          spec:
            project: default
            source:
              repoURL: https://github.com/SLMakomazi/TasklistApp.git
              targetRevision: HEAD
              path: k8s
            destination:
              server: https://kubernetes.default.svc
              namespace: tasklist
            syncPolicy:
              automated:
                prune: true
                selfHeal: true
              syncOptions:
                - CreateNamespace=true
          EOF
          
          echo "âœ… ArgoCD application created"
          echo "ðŸ”— ArgoCD will automatically sync the k8s directory"

      - name: Upload kubeconfig
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: kubeconfig
          path: /home/siseko/microk8s-kubeconfig
          if-no-files-found: error
          retention-days: 1
