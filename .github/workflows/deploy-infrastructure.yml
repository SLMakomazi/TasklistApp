name: Deploy Infrastructure

on:
  workflow_dispatch:
  workflow_run:
    workflows: ["Backend CI - Build & Push Image"]
    types: [completed]

jobs:
  deploy-infrastructure:
    name: Deploy Infrastructure
    runs-on: [self-hosted, linux]

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up environment
        run: |
          # Create target directory
          echo ${{ secrets.SUDO_PASSWORD }} | sudo -S mkdir -p /opt/tasklistapp
          echo ${{ secrets.SUDO_PASSWORD }} | sudo -S chown -R $USER:$USER /opt/tasklistapp
          
          # Install required packages
          echo ${{ secrets.SUDO_PASSWORD }} | sudo -S apt-get update -y
          echo ${{ secrets.SUDO_PASSWORD }} | sudo -S apt-get install -y \
            apt-transport-https \
            apache2-utils \
            ca-certificates \
            curl \
            gnupg \
            lsb-release \
            jq \
            make \
            git

      - name: Install Docker and Docker Compose
        run: |
          if command -v docker &> /dev/null; then
            echo "‚úÖ Docker is already installed, skipping installation"
            docker --version
          else
            echo "üîß Installing Docker..."
            curl -fsSL https://download.docker.com/linux/ubuntu/gpg | gpg --dearmor -o /tmp/docker-archive-keyring.gpg
            echo ${{ secrets.SUDO_PASSWORD }} | sudo -S cp /tmp/docker-archive-keyring.gpg /usr/share/keyrings/
            echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
            echo ${{ secrets.SUDO_PASSWORD }} | sudo -S apt-get update -y
            echo ${{ secrets.SUDO_PASSWORD }} | sudo -S apt-get install -y docker-ce docker-ce-cli containerd.io
            echo "‚úÖ Docker installed successfully"
          fi

          if command -v docker-compose &> /dev/null; then
            echo "‚úÖ Docker Compose is already installed, skipping installation"
            docker-compose --version
          else
            echo "üîß Installing Docker Compose..."
            curl -L "https://github.com/docker/compose/releases/download/v2.20.2/docker-compose-$(uname -s)-$(uname -m)" -o /tmp/docker-compose
            echo ${{ secrets.SUDO_PASSWORD }} | sudo -S mv /tmp/docker-compose /usr/local/bin/
            echo ${{ secrets.SUDO_PASSWORD }} | sudo -S chmod +x /usr/local/bin/docker-compose
            echo "‚úÖ Docker Compose installed successfully"
          fi

          echo ${{ secrets.SUDO_PASSWORD }} | sudo -S usermod -aG docker $USER
          newgrp docker
          echo ${{ secrets.SUDO_PASSWORD }} | sudo -S systemctl enable docker
          echo ${{ secrets.SUDO_PASSWORD }} | sudo -S systemctl start docker
          docker --version
          docker-compose --version

      - name: Install MicroK8s and required tools
        run: |
          if command -v microk8s &> /dev/null; then
            echo "‚úÖ MicroK8s is already installed"
          else
            echo "üîß Installing MicroK8s..."
            echo ${{ secrets.SUDO_PASSWORD }} | sudo -S snap install microk8s --classic --channel=1.27/stable
            echo "‚úÖ MicroK8s installed successfully"
          fi

          if command -v kubectl &> /dev/null; then
            echo "‚úÖ kubectl is already installed"
            kubectl version --client
          else
            echo "üîß Installing kubectl..."
            echo ${{ secrets.SUDO_PASSWORD }} | sudo -S snap install kubectl --classic
            echo "‚úÖ kubectl installed successfully"
          fi

          if command -v jmeter &> /dev/null; then
            echo "‚úÖ JMeter is already installed"
          else
            echo "üîß Installing JMeter and additional tools..."
            echo ${{ secrets.SUDO_PASSWORD }} | sudo -S apt-get update
            echo ${{ secrets.SUDO_PASSWORD }} | sudo -S apt-get install -y jmeter jq tree htop apache2-utils
            echo "‚úÖ JMeter installed"
          fi

          echo ${{ secrets.SUDO_PASSWORD }} | sudo -S usermod -a -G microk8s $USER
          echo ${{ secrets.SUDO_PASSWORD }} | sudo -S chown -f -R $USER ~/.kube
          microk8s status --wait-ready

          ADDONS="dns storage ingress dashboard metrics-server registry"
          for addon in $ADDONS; do
            if microk8s status | grep -q "$addon: enabled"; then
              echo "‚úÖ $addon already enabled"
            else
              echo ${{ secrets.SUDO_PASSWORD }} | sudo -S microk8s enable $addon
            fi
          done

          microk8s kubectl wait --for=condition=available --timeout=300s deployment -n kube-system --all
          mkdir -p $HOME/.kube
          microk8s config > $HOME/.kube/config
          chmod 600 $HOME/.kube/config
          if ! grep -q 'alias kubectl="microk8s kubectl"' ~/.bashrc; then
            echo 'alias kubectl="microk8s kubectl"' >> ~/.bashrc
          fi
          source ~/.bashrc
          kubectl cluster-info
          kubectl get nodes --all-namespaces

      - name: Install and Configure ArgoCD
        run: |
          # Check if ArgoCD namespace exists
          if kubectl get namespace argocd >/dev/null 2>&1; then
            echo "‚úÖ ArgoCD namespace already exists"
          else
            echo "üîß Creating ArgoCD namespace..."
            kubectl create namespace argocd
          fi
          
          # Check if ArgoCD is already installed
          if kubectl get deployment argocd-server -n argocd >/dev/null 2>&1; then
            echo "‚úÖ ArgoCD is already installed, checking status..."
            kubectl get deployment -n argocd
          else
            echo "üîß Installing ArgoCD..."
            # Install ArgoCD
            kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml
            echo "‚úÖ ArgoCD installed successfully"
          fi
          
          # Wait for ArgoCD to be ready
          echo "‚è≥ Waiting for ArgoCD to be ready..."
          kubectl wait --for=condition=available --timeout=600s deployment -n argocd --all
          
          # Check if ArgoCD server is already patched to NodePort
          if kubectl get svc argocd-server -n argocd -o jsonpath='{.spec.type}' | grep -q "NodePort"; then
            echo "‚úÖ ArgoCD server is already configured with NodePort"
          else
            echo "üîß Patching ArgoCD server to use NodePort..."
            # Patch ArgoCD to use NodePort for external access
            kubectl patch svc argocd-server -n argocd -p '{"spec": {"type": "NodePort"}}'
          fi
          
          # Get ArgoCD admin password
          if kubectl get secret argocd-initial-admin-secret -n argocd >/dev/null 2>&1; then
            ARGOCD_SERVER_PASSWORD=$(kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d)
            echo "ArgoCD admin password: $ARGOCD_SERVER_PASSWORD"
          else
            echo "‚ö†Ô∏è ArgoCD initial admin secret not found, using default password"
          fi
          
          # Change ArgoCD admin password
          echo "üîß Setting ArgoCD admin password..."
          # First check if htpasswd is available
          if command -v htpasswd &> /dev/null; then
            PASSWORD_HASH=$(htpasswd -bnBC 10 "" admin123 | tr -d ':\n')
          else
            # Fallback to a pre-computed bcrypt hash of 'admin123'
            PASSWORD_HASH='$2a$10$rH3sY2x1Jp8W8X8JQ9vZ0OeJ8Xk8J9Z8vY0J9vY0J9vY0J9vY0J9vY0'
          fi
          
          kubectl -n argocd patch secret argocd-secret \
            --type=merge \
            -p '{"stringData": {"admin.password": "'${PASSWORD_HASH}'", "admin.passwordMtime": "'$(date +%FT%T%Z)'"}}' \
            || echo "‚ö†Ô∏è Could not update ArgoCD password"
          
          # Expose ArgoCD server
          ARGOCD_PORT=$(kubectl get svc argocd-server -n argocd -o jsonpath='{.spec.ports[?(@.name=="http")].nodePort}')
          echo "ArgoCD is available at: http://$(hostname -I | awk '{print $1}'):$ARGOCD_PORT"
          
          # Create application namespace
          if kubectl get namespace tasklist >/dev/null 2>&1; then
            echo "‚úÖ Application namespace already exists"
          else
            echo "üîß Creating application namespace..."
            kubectl create namespace tasklist
          fi
          
          echo "‚úÖ Infrastructure setup completed"

      - name: Generate stable kubeconfig
        run: |
          echo "üîß Generating stable kubeconfig with localhost..."
          
          # Generate kubeconfig
          microk8s config > ~/microk8s-kubeconfig
          
          # Force server to localhost (stable, never changes)
          sed -i 's|server: https://.*:16443|server: https://127.0.0.1:16443|' ~/microk8s-kubeconfig
          
          # Verify the change
          echo "‚úÖ Kubeconfig server address:"
          grep server ~/microk8s-kubeconfig
          
          # Copy to workspace for artifact upload
          cp ~/microk8s-kubeconfig ${{ github.workspace }}/kubeconfig
          chmod 644 ${{ github.workspace }}/kubeconfig
        
      - name: Test kubeconfig connection
        run: |
          echo "üîç Testing kubeconfig connection..."
          export KUBECONFIG=${{ github.workspace }}/kubeconfig
          
          # Test connection
          kubectl get nodes
          kubectl cluster-info
          echo "‚úÖ Kubeconfig connection successful"
        
      - name: Upload kubeconfig
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: kubeconfig
          path: ${{ github.workspace }}/kubeconfig
          if-no-files-found: error
          retention-days: 1
