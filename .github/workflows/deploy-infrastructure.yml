name: Deploy Infrastructure

on:
  workflow_dispatch:
  workflow_run:
    workflows: ["Backend CI - Build & Push Image"]
    types: [completed]

jobs:
  deploy-infrastructure:
    name: Deploy Infrastructure
    runs-on: [self-hosted, linux]

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up environment
        run: |
          # Create target directory
          echo ${{ secrets.SUDO_PASSWORD }} | sudo -S mkdir -p /opt/tasklistapp
          echo ${{ secrets.SUDO_PASSWORD }} | sudo -S chown -R $USER:$USER /opt/tasklistapp
          
          # Install required packages
          echo ${{ secrets.SUDO_PASSWORD }} | sudo -S apt-get update -y
          echo ${{ secrets.SUDO_PASSWORD }} | sudo -S apt-get install -y \
            apt-transport-https \
            ca-certificates \
            curl \
            gnupg \
            lsb-release \
            jq \
            make \
            git

      - name: Install Docker and Docker Compose
        run: |
          if command -v docker &> /dev/null; then
            echo "âœ… Docker is already installed, skipping installation"
            docker --version
          else
            echo "ðŸ”§ Installing Docker..."
            curl -fsSL https://download.docker.com/linux/ubuntu/gpg | gpg --dearmor -o /tmp/docker-archive-keyring.gpg
            echo ${{ secrets.SUDO_PASSWORD }} | sudo -S cp /tmp/docker-archive-keyring.gpg /usr/share/keyrings/
            echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
            echo ${{ secrets.SUDO_PASSWORD }} | sudo -S apt-get update -y
            echo ${{ secrets.SUDO_PASSWORD }} | sudo -S apt-get install -y docker-ce docker-ce-cli containerd.io
            echo "âœ… Docker installed successfully"
          fi

          if command -v docker-compose &> /dev/null; then
            echo "âœ… Docker Compose is already installed, skipping installation"
            docker-compose --version
          else
            echo "ðŸ”§ Installing Docker Compose..."
            curl -L "https://github.com/docker/compose/releases/download/v2.20.2/docker-compose-$(uname -s)-$(uname -m)" -o /tmp/docker-compose
            echo ${{ secrets.SUDO_PASSWORD }} | sudo -S mv /tmp/docker-compose /usr/local/bin/
            echo ${{ secrets.SUDO_PASSWORD }} | sudo -S chmod +x /usr/local/bin/docker-compose
            echo "âœ… Docker Compose installed successfully"
          fi

          echo ${{ secrets.SUDO_PASSWORD }} | sudo -S usermod -aG docker $USER
          newgrp docker
          echo ${{ secrets.SUDO_PASSWORD }} | sudo -S systemctl enable docker
          echo ${{ secrets.SUDO_PASSWORD }} | sudo -S systemctl start docker
          docker --version
          docker-compose --version

      - name: Install MicroK8s and required tools
        run: |
          if command -v microk8s &> /dev/null; then
            echo "âœ… MicroK8s is already installed"
          else
            echo "ðŸ”§ Installing MicroK8s..."
            echo ${{ secrets.SUDO_PASSWORD }} | sudo -S snap install microk8s --classic --channel=1.27/stable
            echo "âœ… MicroK8s installed successfully"
          fi

          if command -v kubectl &> /dev/null; then
            echo "âœ… kubectl is already installed"
            kubectl version --client
          else
            echo "ðŸ”§ Installing kubectl..."
            echo ${{ secrets.SUDO_PASSWORD }} | sudo -S snap install kubectl --classic
            echo "âœ… kubectl installed successfully"
          fi

          if command -v jmeter &> /dev/null; then
            echo "âœ… JMeter is already installed"
          else
            echo "ðŸ”§ Installing JMeter and additional tools..."
            echo ${{ secrets.SUDO_PASSWORD }} | sudo -S apt-get update
            echo ${{ secrets.SUDO_PASSWORD }} | sudo -S apt-get install -y jmeter jq tree htop apache2-utils
            echo "âœ… JMeter installed"
          fi

          echo ${{ secrets.SUDO_PASSWORD }} | sudo -S usermod -a -G microk8s $USER
          echo ${{ secrets.SUDO_PASSWORD }} | sudo -S chown -f -R $USER ~/.kube
          microk8s status --wait-ready

          ADDONS="dns storage ingress dashboard metrics-server registry"
          for addon in $ADDONS; do
            if microk8s status | grep -q "$addon: enabled"; then
              echo "âœ… $addon already enabled"
            else
              echo ${{ secrets.SUDO_PASSWORD }} | sudo -S microk8s enable $addon
            fi
          done

          microk8s kubectl wait --for=condition=available --timeout=300s deployment -n kube-system --all
          mkdir -p $HOME/.kube
          microk8s config > $HOME/.kube/config
          chmod 600 $HOME/.kube/config
          if ! grep -q 'alias kubectl="microk8s kubectl"' ~/.bashrc; then
            echo 'alias kubectl="microk8s kubectl"' >> ~/.bashrc
          fi
          source ~/.bashrc
          kubectl cluster-info
          kubectl get nodes --all-namespaces

      - name: Install and Configure ArgoCD
        run: |
          # Check if ArgoCD namespace exists
          if kubectl get namespace argocd >/dev/null 2>&1; then
            echo "âœ… ArgoCD namespace already exists"
          else
            echo "ðŸ”§ Creating ArgoCD namespace..."
            kubectl create namespace argocd
          fi
          
          # Check if ArgoCD is already installed
          if kubectl get deployment argocd-server -n argocd >/dev/null 2>&1; then
            echo "âœ… ArgoCD is already installed, checking status..."
            kubectl get deployment -n argocd
          else
            echo "ðŸ”§ Installing ArgoCD..."
            # Install ArgoCD
            kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml
            echo "âœ… ArgoCD installed successfully"
          fi
          
          # Wait for ArgoCD to be ready
          echo "â³ Waiting for ArgoCD to be ready..."
          kubectl wait --for=condition=available --timeout=600s deployment -n argocd --all
          
          # Check if ArgoCD server is already patched to NodePort
          if kubectl get svc argocd-server -n argocd -o jsonpath='{.spec.type}' | grep -q "NodePort"; then
            echo "âœ… ArgoCD server is already configured with NodePort"
          else
            echo "ðŸ”§ Patching ArgoCD server to use NodePort..."
            # Patch ArgoCD to use NodePort for external access
            kubectl patch svc argocd-server -n argocd -p '{"spec": {"type": "NodePort"}}'
          fi
          
          # Get ArgoCD admin password
          if kubectl get secret argocd-initial-admin-secret -n argocd >/dev/null 2>&1; then
            ARGOCD_SERVER_PASSWORD=$(kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d)
            echo "ArgoCD admin password: $ARGOCD_SERVER_PASSWORD"
          else
            echo "âš ï¸ ArgoCD initial admin secret not found, using default password"
          fi
          
          # Change ArgoCD admin password
          echo "ðŸ”§ Setting ArgoCD admin password..."
          kubectl -n argocd patch secret argocd-secret \
            -p '{"stringData": {
              "admin.password": "'$(htpasswd -bnBC 10 "" admin123 | tr -d ':\n')'",
              "admin.passwordMtime": "'$(date +%FT%T%Z)'"
            }}' \
            --type=merge || echo "âš ï¸ Could not update ArgoCD password"
          
          # Expose ArgoCD server
          ARGOCD_PORT=$(kubectl get svc argocd-server -n argocd -o jsonpath='{.spec.ports[?(@.name=="http")].nodePort}')
          echo "ArgoCD is available at: http://$(hostname -I | awk '{print $1}'):$ARGOCD_PORT"
          
          # Create application namespace
          if kubectl get namespace tasklist >/dev/null 2>&1; then
            echo "âœ… Application namespace already exists"
          else
            echo "ðŸ”§ Creating application namespace..."
            kubectl create namespace tasklist
          fi
          
          # Check if ArgoCD application already exists
          if kubectl get application tasklist-app -n argocd >/dev/null 2>&1; then
            echo "âœ… ArgoCD application already exists"
          else
            echo "ðŸ”§ Creating ArgoCD application..."
            kubectl apply -f - <<EOF
            apiVersion: argoproj.io/v1alpha1
            kind: Application
            metadata:
              name: tasklist-app
              namespace: argocd
            spec:
              project: default
              source:
                repoURL: ${{ github.server_url }}/${{ github.repository }}.git
                targetRevision: HEAD
                path: k8s
              destination:
                server: https://kubernetes.default.svc
                namespace: tasklist
              syncPolicy:
                automated:
                  prune: true
                  selfHeal: true
                syncOptions:
                  - CreateNamespace=true
            EOF
            echo "âœ… ArgoCD application created"
          fi
          
          echo "âœ… ArgoCD setup completed"

      - name: Save kubeconfig
        if: always()
        run: |
          mkdir -p ${{ github.workspace }}/.kube
          cp ~/.kube/config ${{ github.workspace }}/kubeconfig

      - name: Upload kubeconfig
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: kubeconfig
          path: ${{ github.workspace }}/kubeconfig
          if-no-files-found: error
          retention-days: 1
